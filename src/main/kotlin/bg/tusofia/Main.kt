package bg.tusofia

import java.math.BigInteger
import java.security.SecureRandom

object ModArithmetic {
    val P: BigInteger = BigInteger("2147483647")

    fun modAdd(a: BigInteger, b: BigInteger): BigInteger = (a + b).mod(P)
}

class SimpleSecretSharing(private val numParties: Int) {

    fun splitSecret(secret: BigInteger): List<BigInteger> {
        val shares = mutableListOf<BigInteger>()

        // Generate (numParties - 1) random shares
        for (i in 1 until numParties) {
            shares.add(BigInteger(ModArithmetic.P.bitLength(), SecureRandom()))
        }

        // Calculate the final share to ensure the sum mod P equals the secret
        val sumOfShares = shares.reduce { acc, share -> ModArithmetic.modAdd(acc, share) }
        val lastShare = ModArithmetic.modAdd(secret, sumOfShares.negate())
        shares.add(lastShare)

        return shares
    }

    // Secret reconstruction
    fun combineShares(shares: List<BigInteger>): BigInteger {
        return shares.reduce { acc, share -> ModArithmetic.modAdd(acc, share) }
    }
}

fun main() {
    val numParties = 3
    val secretSharing = SimpleSecretSharing(numParties)

    // private input
    val partyInputs = listOf(
        BigInteger("856"),
        BigInteger("534"),
        BigInteger("5765")
    )
    println("Party Inputs: $partyInputs")

    // Secret sharing for each party
    val shares = partyInputs.map { secretSharing.splitSecret(it) }
    println("Shares generated by each party: $shares")

    // Distribute shares: each party gets a share from all others
    val distributedShares = List(numParties) { partyIndex ->
        List(numParties) { partySharesIndex ->
            shares[partySharesIndex][partyIndex]
        }
    }
    println("Distributed Shares: $distributedShares")

    // Each party adds the shares they received for secure addition
    val localSums = distributedShares.map { it.reduce { acc, share -> ModArithmetic.modAdd(acc, share) } }
    println("Local Sums (Partial Results): $localSums")

    // Combine local sums to get the final sum securely
    val finalSum = secretSharing.combineShares(localSums)
    println("Final Secure Sum: $finalSum")

    // Validation
    val expectedSum = secretSharing.combineShares(partyInputs)
    println("Expected Secure Sum: $expectedSum")
}
